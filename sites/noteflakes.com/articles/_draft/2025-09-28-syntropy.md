---
title: "Software as Craft: a First Look at Syntropy"
layout: article
---

I've always been interested in coding as a craft - a thing to do with your
hands, your eyes and your mind. In many ways, I feel that a lot of the
satisfaction and accomplishment I get from making software comes from the
process itself, the doing of it, and not necessarily the end result. To quote
[one of my favorite musicians](https://en.wikipedia.org/wiki/Tom_Waits):

> Most vagabonds I knowed don't ever want to find the culprit <br>
> That remains the object of their long relentless quest, <br>
> **The obsession's in the chasing and not the apprehending**, <br>
> The pursuit you see and never the arrest. <br>
>
> - Tom Waits, [Foreign Affair](https://www.youtube.com/watch?v=-iTLk3gjEec)

This is also one of the reasons why the recent AI hype doesn't really resonate
with me. They say about us software developers that we always are looking to
automate our workflows, but personally this is not what's driving me. I'm not
interested in automating my work. I don't mind spending a few more minutes on
writing another REST controller, or some Javascript keyboard event handler, or
just copying files and manually setting up a new server. And anyways I probably
spend more time thinking about a problem than actually coding the solution!

To me this is all part of the process, it's all enjoyable, and since I'm my own
boss, I have the luxury of taking my time. My clients know that I'm dependable
and available when there's a problem, and that I get the job done, so I can
concentrate on the process itself, and not worry so much on *velocity*.

This is also why I like to make my own tools, instead of just blindly relying on
some ready-made frameworks or libraries. It's not only about freedom, it's also
about the joy of creation, and the deeper understanding and knowledge of the
lower-level aspects of the system I'm building, be it HTTP, TCP, SQL, Syscalls,
forking, process signals etc. I like to tell people that my job is really
digital plumbing - it's really about tinkering with machines and hooking them up
to each other.

## Are We All Just CRUD Monkeys?

Now don't get me wrong, I totally understand the value of using frameworks such
as [Ruby on Rails](https://rubyonrails.org/), and the whole ecosystem that goes
with it. Rails provides teremendous value to developers, and a structure for
building web apps in big teams. And it also demands a deep knowledge, but of a
different kind. Instead of learning about low-level stuff, you learn about what
solutions already exist for the problem you're trying to solve, and how to use
them. It's sort of like the difference between knowing how to properly sharpen
and use a wood chisel, and knowing how to properly choose and use a tenoning
machine.

It's perfectly fine to build yourself a career on top of Ruby on Rails, call
yourself a [CRUD
monkey](https://youtu.be/gcwzWzC7gUA?si=KkZRqG9w3U3v3BV-&t=326), and now with
the help of AI technologies you can have an *entire army* of CRUD monkeys at
your service. DHH says he's built an entire career on being a CRUD monkey, but
in a way that's not true. Rather, he's created Ruby on Rails (of course, with
the help of many other contributors), which is a great piece of software that in
many ways has revolutionized web development. So perhaps it's more accurate to
say that he made a career on *turning other people into CRUD monkeys*. But I
think for him also, there's the joy of working on Ruby on Rails itself, and not
only using it to make CRUD apps.

## Ruby is not Only Rails

One big problem we have in the Ruby community is the somewhat disproportionate
place Rails has in the ecosystem. While there's still a lot happening in the
community that has little to do with Rails, it does seem to me that most of the
activity is still around Rails. At the recent [Euruko
conference](https://noteflakes.com/articles/2025-09-23-euruko) in Viana do
Castelo, by my count more than half of the talks were about Rails or tools that
integrate with Rails. In and of itself this is not necessarily a bad thing, but
I found it a bit sad that there was no presence (as far as I could tell) for any
other web framework: no Roda, no Hanami, no Sinatra. Maybe this is just the
nature of things, but is it really desirable?

Personally, I don't mind so much that Rails has such a dominant position. After
all, I don't use it, so it doesn't have much impact on my work. Rails provides a
lot of value for developers. But there *are* other approaches possible, and
maybe Rails can even learn from them. There *are* precedents:
[Merb](https://github.com/merb/merb) was a simpler and faster alternative to
Rails, before being *merged* into Rails.
[Sequel](https://sequel.jeremyevans.net/) has shown developers that there are
better ways to work with databases, and then ActiveRecord got Arel. So Rails can
also gain from more innovation in the Ruby ecosystem.

## A First Look at Syntropy

So with that in mind, I'd like to share with you a first look at the web
framework I'm currently working on, which I call
[Syntropy](https://github.com/noteflakes/syntropy/), and which actually is what
drives this website.

> I chose the name Syntropy because in the last few years I've been passionate
> about [Syntropic
> Agroforestery](https://en.wikipedia.org/wiki/Agroforestry#Syntropic_systems)
> as an approach to agriculture (I'm an amateur gardener), and to the
> cultivation of rich and diverse ecosystems that are also beneficial to human
> beings.
> 
> Syntropy is kind of the inverse of entropy. While entropy is the natural
> tendency of a given system towards disorder and decay and homogeneity,
> syntropy is the power of life to create order out of chaos, to concentrate
> energy in various life forms, and to create more and more diversity and
> abundance.
>
> When you think about it, life is the only thing in the universe that can go
> against the entropy of the universe - it can create forms, it can concentrate
> energy and matter in living things. Syntropy is an approach that takes that
> observation and applies it to agriculture - how we can harness this power of
> life to overcome entropy, and how we can work with ecosystems to create more
> richness, more diversity, and more abundance, not only for human beings, but
> for *all* living things.
>
> This is why I'm so passionate about this concept, because it offers us not
> only a vision of true abundance, but also an alternative to our current
> social, political and economic structures that have a "zero-sum game"
> approach.
>
> Living, abundant ecosystems teach us that in fact each of us is valuable to
> our societies and that sharing in the abundance just brings more abundance.
> Food for thought...

The original inspiration for Syntropy came from Jekyll - a static site
generator, which I have used previously for my blog. In Jekyll, like all other
SSGs I guess, the URL structure of the website mirrors the directory structure
of the source code. To illustrate what I mean, we can take the following
directory structure and the corresponding mappings to URLs:

```
files                     URLs
=====                     ====
+ site/
  + index.html            /
  + about/
    + index.md            /about
  + blog/
    + 2025-01-foo.md      /blog/2025-01-foo
    + 2025-02-bar.md      /blog/2025-02-bar
```

Now in the above example we just have a bunch of HTML and Markdown files, but we
can also have "asset" files such as CSS, JS and images. You can also see that
the routing scheme is very easy to understand: URLs are hierarchical in nature,
and the fact they mirror the directory structure makes it trivial to organize
the site's source code.

So the question I asked myself was: what if I had a tool like Jekyll for
creating websites but with support for dynamic content? What would be the
implications of that for the way the source code is organized? What does this do
to the
[MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)
pattern?

## File-Based Routing

I spent some time researching existing solutions for this in Ruby or in other
programming languages. First of all there's
[Bridgetown](https://www.bridgetownrb.com), a Ruby-based SSG which also offers
the possibility of adding dynamic content via
[Roda](https://roda.jeremyevans.net/), which means that you can make hybrid
sites that use markdown for static content, and Roda for the dynamic parts. You
do need to express the dynamic routing with a Roda dynamic tree, which is
expressed in code. So, you can only use file-based routing for the static parts
of your site.

It should also be noted that PHP web apps by default use file-based routing, but
if you want to implement some more advanced patterns, such as clean URLs, or
maybe parametric routes, you'll need to fiddle with your HTTP server's
configuration (be it Apache, Nginx, Caddy or something else.)

I've also looked at a few different Javascript routers that use file-based
routing, such as [Expo](https://docs.expo.dev/develop/file-based-routing/),
[Tanstack Router](https://tanstack.com/router/latest), [React
Router](https://reactrouter.com/how-to/file-route-conventions), and finally
[SvelteKit](https://svelte.dev/docs/kit/routing).

I think out of all of those different solutions the most comprehensive is the
SvelteKit router, but it does have some peculiarities: all routes must be
defined as directories, and for each route there's a convention for filenames
for different aspects of route controllers. Because SvelteKit deals with both
frontend and backend concerns, you need to separate the frontend code and
backend code into separate files, namely `+page.js` and `+page.server.js`. You
can also create files for layouts and error handling, and to me it gets a bit
confusing very fast.

But what I learned is that there are some useful conventions that have been
adopted by these different solutions:

- Files starting with an underscore (e.g. `_foo.js`) are considered internal and
  not exposed by the application.
- Parametric routes are defined using square brackets, e.g. `foo/[id].js`.
- Index files point to their containing directory, so `/foo/index.js` points to
  `/foo`.

## Code Organization

Another problem I had to tackle was how to organize code. Let's take as an
example a blog-type website, where all the pages are dynamic:

```
files                   URLs
=====                   ====
+ site/
  + index.rb            /
  + about.rb            /about
  + rss.rb              /rss
  + blog/
    + index+.rb         /blog/*
  + _articles/
    + 2025-01-foo.md
    + 2025-02-bar.md
```

How should these controllers look? Do we define some uniform interface? How do
they get loaded? Do they only act as view templates, or can they do more than
that? How are layout templates defined? What if you need to compose them in some
way? How do you deal with middleware?




















## The Syntropy Routing Tree

With those conventions in mind I started working on a router implementation. My
main objectives were to build something simple, self contained and that worked
fast. As is my custom these last few years, when I implement a new feature, or
when I do research on possible solutions to a problem, I prefer to start at the
end. This means that I prefer to start with some piece of code that represents
the solution I want to achieve. In the case of the router I wanted to model the
router as a pure function that takes a URL path as an input, and returns some
kind of route object as an output. The route object is then used to process the
incoming request:

```ruby
router = ->(path) { ... }

# handle incoming request
route = router.(request.path)
handle_request(route, request)
```

So this is the end result that we want to achieve. Let's look at how we can do
this. In general terms, there are two different approaches we can use to find
the route for a given path:

- We can precalculate a mapping of URL paths to file paths. Or:
- We can parse each segment of the URL path, and traverse some kind of tree
  structure.

The first approach works very well for a majority of the cases, but it falls
short if you want to support parametric routes or wildcard routes. A parametric
route is a route where one or more segments are in fact parameters. If we look
at GitHub URL's, for example, we can see that parts of the URL are in fact
parameters: the URL `github.com/ruby/openssl/issues/920` in fact includes
multiple parameters: `github.com/[org]/[repo]/issues/[id]`. A wildcard route is
a route that handles not only itself but also any URL in its subtree. For
example, the URL `github.com/ruby/openssl/blob/master/lib/openssl/bn.rb` is in
fact of the form `github.com/[org]/[repo]/blob/[branch]/[file_path]+`, where
`file_path` is in fact a subtree wildcard. Both of those cases represent dynamic
routes, that cannot be known in advance. So, a hash mapping URLs to files cannot
be used to find both these kinds of routes.

The second approach *can* be used to deal with such *dynamic* routes, but as you
can imagine is much much slower, because you can't just do a lookup for the
entire path, you to look at each segment of it in its turn. So, supposing we
want to have support for dynamic routes (which we do), we need to find a way to
do so in the most efficient manner possible.

So lets look at how we can deal with the two types of routes we have: static
routes, and dynamic routes.

## Static Routes

Routing to static files is actually very simple: it consists of scanning a list
of files, and then generating a hash mapping URLs to those files:

```ruby
static_routes = Dir[File.join(site_root, '**/*')].inject({}) do |h, fn|
  url = fn_to_url(fn)
  h[url] = fn
  h
end
```

Once we have generated this map, it's trivial to use it:

```ruby
router = ->(path) {
  fn = static_routes[path]

  # return a hash indicating the route type and the target file's path
  {
    kind: :static,
    fn:   fn
  }
}
```

## Dynamic Routes

Let's now look at the more complex case: that of parametric routes and wildcard
routes. Those kinds of routes necessitate parsing the path, looking at each
segment separately. Let's suppose we have the following directory structure,
that mimics some of GitHub's functionalities:

```
+ site/
  + [org]/
  | + [repo]/
  |   + issues/
  |   | + [id].rb
  |   + pull/
  |     + [id].rb
  + collections.rb
  + explore.rb
  + index.rb
```

So let's see how we can take this directory structure 













--------------------------------------------------------------------------------

You can look at the router implementation
[here](https://github.com/digital-fabric/syntropy/blob/main/lib/syntropy/routing_tree.rb).
It's a single source file with probably as many comments as lines of code. I
wanted the implementation to be completely self contained and without any 